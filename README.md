# Elixir 

# Base Library for REST CRUD in Spring Boot

Java (Maven) module that provides a reusable base layer for building REST APIs over Spring (Web MVC + Data JPA), featuring:

- Generic CRUD controllers (`BaseController`)
- Generic services with common logic (`BaseService`)
- Base repository (`BaseRepository`) on Spring Data JPA
- Standardized response DTO (`APIResponse`) and status enum (`Status`)
- Utility mapper (`MapperBase`) for success responses
- Global error handling with semantic exceptions and a centralized handler
- Default CORS configuration (`WebConfig`)
- Health/diagnostic endpoints (`SystemStatusController`)

This module is designed as a library to speed up the creation of microservices and modules with standard CRUD behavior.  
It’s published as a JAR and integrated into Spring Boot applications.

## Stack and Dependencies

The submodule `backend/elixir` inherits its dependencies from the parent module `backend` (packaging = POM).

Main components:

- Spring Boot Web: `spring-boot-starter-web`
- Spring Data JPA: `spring-boot-starter-data-jpa`, `spring-data-jpa`
- Spring Data REST (optional, inherited from parent)
- Springdoc OpenAPI UI: `springdoc-openapi-starter-webmvc-ui`
- Jakarta Persistence API: `jakarta.persistence-api`
- Lombok (compile-time): `lombok`
- Testing: `spring-boot-starter-test`

Packaging: `jar`

## Layered Architecture and Typical Flow

- Controller → Service → Repository → DB
- All success responses are wrapped in `APIResponse<T>` with `status = Status.SUCCESS`
- Errors are caught by the global handler and returned as `APIResponse<?>` with `status = Status.ERROR` and a list of `ErrorDTO`

Generic CRUD flow:

1) `BaseController` exposes REST endpoints (POST, GET, PUT, DELETE) and delegates to the Service.
2) `BaseService` implements logic: creation, existence check, retrieval, update, and deletion. Uses `BaseRepository`.
3) `MapperBase` wraps results into `APIResponse` with `Status.SUCCESS`.
4) Semantic exceptions (`NotFoundException`, `AlreadyExistException`, etc.) are converted to HTTP responses by `RestResponseEntityExceptionHandler`.

## Main Classes

- **configuration/WebConfig**
    - Enables Web MVC and configures CORS: `allowedOrigins(*)`, methods: PUT, DELETE, GET, POST.
    - Note: restrict origins in production.

- **controllers/IBaseController**
    - Interface for methods: `create`, `getById`, `getAll`, `update`, `delete`.
    - Annotated with OpenAPI (`Operation`/`ApiResponses`) for documentation.

- **controllers/BaseController**
    - Abstract implementation mapping REST endpoints:
        - POST `/` → create
        - GET `/{id}` → getById
        - GET `/` → getAll
        - PUT `/{id}` → update
        - DELETE `/{id}` → delete (204 on success, 403 on failure)
    - Requires a specific `BaseService` per entity.

- **controllers/SystemStatusController**
    - GET `/status` → 202 Accepted with body `"All Good."`.
    - GET `/status/error` → throws `DefaultException` to test the global handler.

- **services/interfaces/IBaseService**
    - Generic CRUD interface returning `APIResponse`.

- **services/BaseService**
    - Generic abstract implementation on top of `BaseRepository`.
    - `create(E entity)`: validates existence (`checkIfExist`) and persists; wraps in `APIResponse`.
    - `checkIfExist(E entity)`: iterates through `findAll()` and compares using `equals()`.
        - Note: the base implementation uses `equals()` from the entity; override `equals/hashCode` or `checkIfExist`
          in concrete services for real uniqueness rules or custom queries.
    - `findById(ID id)`, `findAll()`, `update(ID id, E entity)`, `delete(ID id)` — return `APIResponse`, throw `NotFoundException` when needed.

- **repositories/BaseRepository**
    - `@NoRepositoryBean` extending `JpaRepository<E, ID>` — base for entity-specific repositories.

- **entities/Base**
    - `@MappedSuperclass` with autogenerated `id` (Long, `IDENTITY`).

- **entities/Status**
    - Enum: `SUCCESS`, `ERROR`. Used in `APIResponse`.

- **dtos/APIResponse**
    - Generic wrapper with: `data`, `status`, `error: List<ErrorDTO>`; `@JsonInclude(NON_NULL)`. Built with Lombok Builder.

- **dtos/ErrorDTO**
    - Immutable `record (field, message)` detailing errors.

- **dtos/mapper/MapperBase**
    - `toDTO(T)` → returns `APIResponse<T>` with `Status.SUCCESS` and `data`.

- **exceptions/** and **handler**
    - Base checked `ResponseException` with fields `message` and `name`.
    - Specific ones: `AlreadyExistException`, `NotFoundException`, `OperationNotSupportedException`.
    - `DefaultException` (runtime) for generic errors.
    - `RestResponseEntityExceptionHandler` (`@RestControllerAdvice`) maps:
        - `DefaultException` → 409 CONFLICT (plain string)
        - `NotFoundException` → 404 NOT_FOUND (`APIResponse` with `ErrorDTO`)
        - `AlreadyExistException` → 403 FORBIDDEN (`APIResponse` with `ErrorDTO`)
        - `OperationNotSupportedException` → 405 METHOD_NOT_ALLOWED (`APIResponse` with `ErrorDTO`)

## Included Endpoints (Diagnostics)

- GET `/status` → 202 Accepted, body: `"All Good."`
- GET `/status/error` → throws `DefaultException` (to test error handling)

## Extension Guide: Creating a CRUD for a Specific Entity

1. **Entity**
    ```java
    @Entity
    @Table(name = "products")
    public class Product extends Base {
      @Column(nullable=false)
      private String name;
      // equals/hashCode recommended if you use base checkIfExist
    }
    ```
2. **Repository**

    ```java
    @Repository
    public interface ProductRepository extends BaseRepository<Product, Long> {
      boolean existsByName(String name);
    }
    ```

3. **Service**

    ```java
    @Service
    public class ProductService extends BaseService<Product, Long> {
      private final ProductRepository repo;
      public ProductService(ProductRepository repo) { super(repo); this.repo = repo; }
      @Override
      public boolean checkIfExist(Product p) { return repo.existsByName(p.getName()); }
    }
    ```

4. **Controller**

    ```java
    @RestController
    @RequestMapping("/products")
    public class ProductController extends BaseController<Product, ProductService> {
      public ProductController(ProductService service) { super(service); }
    }
    ```

This automatically exposes:

* POST `/products/`
* GET `/products/{id}`
* GET `/products/`
* PUT `/products/{id}`
* DELETE `/products/{id}`

All responses follow `APIResponse`, and errors are mapped by the global handler.

## CORS

`WebConfig` allows any origin (`*`) and methods PUT, DELETE, GET, POST for all paths. **Adjust for production.**

## Tests

* `SystemStatusControllerTest`: validates 202 and body from `/status` endpoint.
* `BaseTest`: getters/setters and `Base` contract.
* `StatusTest`: enum values.
* `BaseServiceTest`: example using Mockito over `IBaseService` to validate response contract.

## Build and Usage

* Requirements: JDK 16+, Maven 3.9+
* From repo root:

    * `mvn -q -DskipTests package` builds all modules (including `elixir`).
* For submodule only:

    * `cd backend/elixir`
    * `mvn -q -DskipTests package`

This module is a library; it does not contain a `@SpringBootApplication` class.
Use it from a Spring Boot app (by adding it as a dependency) or as part of the multi-module setup.

## Best Practices and Notes

* Implement `equals/hashCode` in your entities or override `checkIfExist` for real uniqueness rules (more efficient than iterating `findAll`).
* Restrict CORS to specific origins in production.
* Use Springdoc: once integrated, Swagger UI will be available at `/swagger-ui.html` or `/swagger-ui/index.html`.
* Use `MapperBase` for consistent success responses.

## Quickstart (5 minutes) — How to Use Elixir in Your Spring Boot App

Note: You can conceptually follow how it’s used in the `joyel` module, but **do not reuse its classes**.
You can invent a simple entity (e.g., `Task` or `User`), or create your own `Parameters` entity.
Here we’ll use `Task` as an example.

### 1) Dependencies

If your project already includes this repo as a multi-module, nothing to add.
If using it as an external dependency (published in GitHub Packages):

```xml
<dependency>
  <groupId>tech.pasaperez</groupId>
  <artifactId>elixir</artifactId>
    <version>[1.0.0,)</version>
</dependency>
```

For a Quickstart with an in-memory DB, add H2:

```xml
<dependency>
  <groupId>com.h2database</groupId>
  <artifactId>h2</artifactId>
  <scope>runtime</scope>
</dependency>
```

### 2) Minimal Configuration (application.yml)

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:demo;DB_CLOSE_DELAY=-1;MODE=MySQL
    driver-class-name: org.h2.Driver
    username: sa
    password: ''
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  h2:
    console:
      enabled: true
```

### 3) Example Entity: Task

```java
package demo.todo;

import jakarta.persistence.*;
import lombok.*;
import tech.pasaperez.elixir.entities.Base;

@Entity
@Table(name="tasks")
@Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of={"title"})
public class Task extends Base {
  @Column(nullable=false, unique=true)
  private String title;

  @Column(nullable=false)
  private String status; // e.g.: PENDING, IN_PROGRESS, DONE
}
```

### 4) Repository

```java
package demo.todo;

import org.springframework.stereotype.Repository;
import tech.pasaperez.elixir.repositories.BaseRepository;

@Repository
public interface TaskRepository extends BaseRepository<Task, Long> {
  boolean existsByTitle(String title);
}
```

### 5) Service

```java
package demo.todo;

import org.springframework.stereotype.Service;
import tech.pasaperez.elixir.services.BaseService;

@Service
public class TaskService extends BaseService<Task, Long> {
  private final TaskRepository repo;
  public TaskService(TaskRepository repo) { super(repo); this.repo = repo; }
  @Override
  public boolean checkIfExist(Task t) { return repo.existsByTitle(t.getTitle()); }
}
```

### 6) Controller

```java
package demo.todo;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import tech.pasaperez.elixir.controllers.BaseController;

@RestController
@RequestMapping("/tasks")
public class TaskController extends BaseController<Task, TaskService> {
  public TaskController(TaskService service) { super(service); }
}
```

### 7) Spring Boot Application

```java
package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
  static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }
}
```

Place your classes under a common root package (e.g., `demo`) and keep `elixir` as a dependency.
Spring Boot will automatically scan your app’s beans; `elixir` provides only abstract/util components and the global handler.

### 8) Test with cURL

Create a task:

```bash
curl -X POST http://localhost:8080/tasks/ \
  -H "Content-Type: application/json" \
  -d '{"title":"Buy bread","status":"PENDING"}'
```

List:

```bash
curl http://localhost:8080/tasks/
```

Get by ID (1):

```bash
curl http://localhost:8080/tasks/1
```

Update:

```bash
curl -X PUT http://localhost:8080/tasks/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Buy bread","status":"DONE"}'
```

Delete:

```bash
curl -X DELETE http://localhost:8080/tasks/1 -i
# Expect 204 No Content if deleted successfully
```

### 9) Error Handling (Expected Responses)

* **Nonexistent resource:**

```json
{
  "status": "ERROR",
  "error": [{"field":"Detail","message":"Resource not found with id: 999"}]
}
```

* **Duplicate resource (create with repeated title):** HTTP 403 with `status: ERROR` and details in `error`.

* **Test error `/status/error`:** HTTP 409 with plain string (as defined in `RestResponseEntityExceptionHandler`).

### 10) Alternative with Parameters

If you prefer a configuration-style entity (like “Parameters”):

```java
@Entity
@Table(name="parameters")
public class Parameters extends Base {
  @Column(nullable=false, unique=true) private String key;
  @Column(nullable=false) private String value;
}
```

Then repeat the Repository/Service/Controller steps shown for `Task`.

# LICENSE

Licensed under the GNU Lesser General Public License v3.0 or later (LGPLv3+)
See the LICENSE file for details.
